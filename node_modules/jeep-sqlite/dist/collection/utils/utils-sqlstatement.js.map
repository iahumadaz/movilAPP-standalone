{"version":3,"file":"utils-sqlstatement.js","sourceRoot":"","sources":["../../src/utils/utils-sqlstatement.ts"],"names":[],"mappings":"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","sourcesContent":["export class UtilsSQLStatement {\n\n  static extractTableName(statement: string): string | null  {\n    const pattern = /(?:INSERT\\s+INTO|UPDATE|DELETE\\s+FROM)\\s+([^\\s]+)/i;\n    const match = statement.match(pattern);\n    if (match && match[1]) {\n      const tableName = match[1];\n      return tableName;\n    }\n    return null;\n  }\n\n  static extractWhereClause(statement: string): string | null {\n    const pattern = /WHERE(.+?)(?:ORDER\\s+BY|LIMIT|$)/i;\n    const match = statement.match(pattern);\n    if (match && match[1]) {\n      const whereClause = match[1].trim();\n      return whereClause;\n    }\n    return null;\n  }\n\n  static addPrefixToWhereClause (whereClause: string,\n                                colNames: string[],\n                                refNames: string[],\n                                prefix: string): string {\n    let columnValuePairs: string[];\n// TODO \"OR\" and \"NOT\"\n    if (whereClause.includes(\"AND\")) {\n      // Split the WHERE clause based on the \"AND\" keyword\n      const subSequenceArray = whereClause.split(\"AND\");\n      columnValuePairs = subSequenceArray.map((pair) => pair.trim());\n    } else {\n      columnValuePairs = [whereClause]\n    }\n\n\n    const modifiedPairs = columnValuePairs.map((pair) => {\n\n      const match = pair.match(/(\\w+)\\s*(=|<|<=|<>|>|>=|IN|BETWEEN|LIKE)\\s*(.+)/);\n      if (!match) {\n        return pair;\n      }\n\n      const column = match[1].trim();\n      const operator = match[2].trim();\n      let value = match[3].trim();\n      let newColumn = column;\n      const index: number = UtilsSQLStatement.findIndexOfStringInArray(column, refNames);\n      if (index !== -1) {\n        newColumn = UtilsSQLStatement.getStringAtIndex(colNames, index);\n      }\n      const modifiedColumn = `${prefix}${newColumn}`;\n      const ret = `${modifiedColumn} ${operator} ${value}`;\n      return ret;\n    });\n\n    return modifiedPairs.join(\" AND \");\n  }\n\n  static findIndexOfStringInArray(target: string, array: string[]): number {\n    return array.indexOf(target);\n  }\n  static getStringAtIndex(array: string[], index: number): string | undefined {\n    if (index >= 0 && index < array.length) {\n      return array[index];\n    } else {\n      return undefined;\n    }\n  }\n  static extractForeignKeyInfo(sqlStatement: string):\n              { forKeys: string[], tableName: string, refKeys: string[],\n                action: string } {\n    // Define the regular expression pattern for extracting the FOREIGN KEY clause\n    const foreignKeyPattern = /\\bFOREIGN\\s+KEY\\s*\\(([^)]+)\\)\\s+REFERENCES\\s+(\\w+)\\s*\\(([^)]+)\\)\\s+(ON\\s+DELETE\\s+(RESTRICT|CASCADE|SET\\s+NULL|SET\\s+DEFAULT|NO\\s+ACTION))?/;\n    const matches = sqlStatement.match(foreignKeyPattern);\n\n    if (matches) {\n        const foreignKeyInfo = {\n            forKeys: matches[1].split(\",\").map(key => key.trim()),\n            tableName: matches[2],\n            refKeys: matches[3].split(\",\").map(key => key.trim()),\n            action: matches[5] ? matches[5] : \"NO ACTION\"\n        };\n        return foreignKeyInfo;\n    } else {\n        throw new Error(\"extractForeignKeyInfo: No FOREIGN KEY found\");\n    }\n  }\n  static extractColumnNames(whereClause: string): string[] {\n    const keywords: Set<string> = new Set([\n      \"AND\", \"OR\", \"IN\", \"VALUES\", \"LIKE\", \"BETWEEN\", \"NOT\"\n    ]);\n\n    const regex = /\\b[a-zA-Z]\\w*\\b(?=\\s*(?:<=?|>=?|<>?|=|AND|OR|BETWEEN|NOT|IN|LIKE))|\\b[a-zA-Z]\\w*\\b\\s+BETWEEN\\s+'[^']+'\\s+AND\\s+'[^']+'|\\(([^)]+)\\)\\s+IN\\s+\\(?\\s*VALUES\\s*\\(/g;\n    let match;\n    const columns: string[] = [];\n\n    while ((match = regex.exec(whereClause)) !== null) {\n      const columnList = match[1];\n      if (columnList) {\n        const columnNamesArray = columnList.split(',');\n        for (const columnName of columnNamesArray) {\n          columns.push(columnName.trim());\n        }\n      } else {\n        const matchedText = match[0];\n        if (!keywords.has(matchedText.trim().toUpperCase())) {\n          columns.push(matchedText.trim());\n        }\n      }\n    }\n\n    return columns;\n  }\n\n  static flattenMultilineString(input: string): string {\n    const lines = input.split(/\\r?\\n/);\n    return lines.join(\" \");\n  }\n\n  static getStmtAndRetColNames(sqlStmt: string, retMode: string):\n                                { stmt: string; names: string } {\n    const retWord = \"RETURNING\";\n    const retStmtNames: { stmt: string; names: string } = { stmt: sqlStmt, names: \"\" };\n\n    const retWordIndex = sqlStmt.toUpperCase().indexOf(retWord);\n    if (retWordIndex !== -1) {\n      const prefix = sqlStmt.substring(0, retWordIndex);\n      retStmtNames.stmt = `${prefix};`;\n\n      if (retMode.substring(0, 2) === \"wA\") {\n        const suffix = sqlStmt.substring(retWordIndex + retWord.length);\n        const names = suffix.trim();\n        if (names.endsWith(\";\")) {\n          retStmtNames.names = names.substring(0, names.length - 1);\n        } else {\n          retStmtNames.names = names;\n        }\n      }\n    }\n\n    return retStmtNames;\n  }\n\n  static extractCombinedPrimaryKey(whereClause: string): string[][] | null {\n    const pattern = /WHERE\\s*\\((.+?)\\)\\s*(?:=|IN)\\s*\\((.+?)\\)/g;\n    const regex = new RegExp(pattern);\n    const matches = whereClause.matchAll(regex);\n\n    const primaryKeySets: string[][] = [];\n    for (const match of matches) {\n      const keysString = match[1].trim();\n      const keys = keysString.split(\",\").map((key) => key.trim());\n      primaryKeySets.push(keys);\n    }\n\n    return primaryKeySets.length === 0 ? null : primaryKeySets;\n  }\n\n  static getWhereStmtForCombinedPK(whStmt: string, withRefs: string[],\n                                  colNames: string[],\n                                  keys: string[][]): string {\n    let retWhere: string = whStmt;\n\n    for (const grpKeys of keys) {\n      const repKeys: string[] = grpKeys.join(\",\") === withRefs.join(\",\") ? colNames : withRefs;\n      for (const [index, key] of grpKeys.entries()) {\n        retWhere = UtilsSQLStatement.replaceAllString(retWhere, key, repKeys[index]);\n      }\n    }\n\n    return retWhere;\n  }\n\n  static replaceAllString(originalStr: string, searchStr: string,\n                                        replaceStr: string): string {\n    return originalStr.split(searchStr).join(replaceStr);\n  }\n\n  static replaceString = (originalStr: string, searchStr: string,\n                                        replaceStr: string): string => {\n    const range = originalStr.indexOf(searchStr);\n    if (range !== -1) {\n      const modifiedStr = originalStr.substring(0, range) + replaceStr + originalStr.substring(range + searchStr.length);\n      return modifiedStr;\n    }\n    return originalStr;\n  }\n\n  static indicesOf(str: string, searchStr: string,\n                                  fromIndex = 0): number[] {\n  // Helper function to find indices of a substring within a string\n  const indices: number[] = [];\n    let currentIndex = str.indexOf(searchStr, fromIndex);\n    while (currentIndex !== -1) {\n      indices.push(currentIndex);\n      currentIndex = str.indexOf(searchStr, currentIndex + 1);\n    }\n    return indices;\n  }\n\n  static getWhereStmtForNonCombinedPK(whStmt: string, withRefs: string[],\n                                      colNames: string[]): string {\n    let whereStmt = \"\";\n    let stmt: string = whStmt.substring(6);\n\n    for (let idx = 0; idx < withRefs.length; idx++) {\n      let colType = \"withRefsNames\";\n      let idxs: number[] = UtilsSQLStatement.indicesOf(stmt, withRefs[idx]);\n      if (idxs.length === 0) {\n        idxs = UtilsSQLStatement.indicesOf(stmt, colNames[idx]);\n        colType = \"colNames\";\n      }\n\n      if (idxs.length > 0) {\n        let valStr = \"\";\n        const indicesEqual = UtilsSQLStatement.indicesOf(stmt, \"=\", idxs[0]);\n\n        if (indicesEqual.length > 0) {\n          const indicesAnd = UtilsSQLStatement.indicesOf(stmt, \"AND\", indicesEqual[0]);\n\n          if (indicesAnd.length > 0) {\n            valStr = stmt.substring(indicesEqual[0] + 1, indicesAnd[0] - 1);\n            stmt = stmt.substring(indicesAnd[0] + 3);\n          } else {\n            valStr = stmt.substring(indicesEqual[0] + 1);\n          }\n          if (idx > 0) {\n            whereStmt += \" AND \";\n          }\n\n          if (colType === \"withRefsNames\") {\n            whereStmt += colNames[idx] + \" = \" + valStr;\n          } else {\n            whereStmt += withRefs[idx] + \" = \" + valStr;\n          }\n        }\n      }\n    }\n\n    whereStmt = \"WHERE \" + whereStmt;\n    return whereStmt;\n  }\n\n  static updateWhere(whStmt: string, withRefs: string[],\n                              colNames: string[]): string {\n    let whereStmt = \"\";\n    if (whStmt.length <= 0) {\n      return whereStmt;\n    }\n    if (whStmt.toUpperCase().substring(0, 5) !== \"WHERE\") {\n      return whereStmt;\n    }\n\n    if (withRefs.length === colNames.length) {\n      // get whereStmt for primary combined key\n      const keys = UtilsSQLStatement.extractCombinedPrimaryKey(whStmt);\n      if (keys) {\n        whereStmt = UtilsSQLStatement.getWhereStmtForCombinedPK(whStmt, withRefs, colNames, keys);\n      } else {\n        // get for non primary combined key\n        whereStmt = UtilsSQLStatement.getWhereStmtForNonCombinedPK(whStmt, withRefs, colNames);\n      }\n    }\n    return whereStmt;\n  }\n}\n"]}